# -*- coding: utf-8 -*-
require "rubygems"
require "ruby-graphviz"
require 'digest/sha1'
require 'pp'
require 'fileutils'
require File.dirname($0) + '/yamlstate.rb'

argv = ARGV
file = argv.shift

BASENAME = File.basename(file,".*")
YAML_DIR = File.dirname(file)
conf_file = YAML_DIR + "/" + BASENAME + ".conf"
conf_file = YAML_DIR + "/default.conf" unless File.exist?(conf_file)
T = BASENAME

namespace = "Gree.Service.ServiceName"
dstbase = "../../UnityProject/Assets/Service"

service_name = nil
if File.exist?(conf_file)
  data = YAML.load(File.read(conf_file))
  namespace = data["namespace"] if data["namespace"] != nil
  service_name = data["dst_dir"] if data["dst_dir"] != nil
else
  service_name = "ServiceName"
end

NAMESPACE = namespace
DST_DIR = dstbase + "/" + service_name
CS_ROOT = File.dirname($0) + "/" + DST_DIR
def export_graph(data)
  g = GraphViz::new(BASENAME)
  nodes = {}
  data.nodes.each do | node |
    shape = "ellipse"
    shape = "box" if node.rlink.empty? || node.link.empty?
    nodes[node.name] = g.add_nodes(node.name, :shape => shape, :URL => "../#{DST_DIR}/#{BASENAME}/StateMachine/#{BASENAME}State#{node.name}.cs")
  end

  data.nodes.each do | node |
    node.link.each do | link |
      if link.condition.nil?
        g.add_edges(nodes[link.from.name], nodes[link.to.name], :weight => "100")
      else
        weight = "1"
        weight = "0.01" if link.from.rlink.empty? || link.to.link.empty?
        g.add_edges(nodes[link.from.name], nodes[link.to.name], :weight => weight, :label => link.condition + "?", :style => "dotted")
      end
    end
  end

  g.output( :pdf => "#{YAML_DIR}/#{BASENAME}.pdf", :png => "#{YAML_DIR}/#{BASENAME}.png",:svg => "#{YAML_DIR}/#{BASENAME}.svg" )
end

def to_condition_text(condition)
  if condition.nil? || condition.empty?
    "false"
  else
    "/* #{condition} ? */ false"
  end
end

def to_comment_text(comment)
  comment = (comment.nil? || comment.empty?) ? "" : " // #{link.name}"
end

def save(funcname, source)
  nospace_source = source.gsub(/[ 	ã€€\n]/, '')
  hash = Digest::SHA1.hexdigest(nospace_source)
  skip_saving = false
  filename = "#{CS_ROOT}/#{BASENAME}/StateMachine/#{BASENAME}#{funcname}.cs"
  current_file = ""
  newly_created = true
  if File.exist?(filename)
    newly_created = false
    File.open(filename,"r:UTF-8"){ | file |
      while l = file.gets
        if l =~ /\/\/\[stateconv\].*\[hash:(.*)\]/
          return if hash == $1
        else
          current_file << l
        end
      end
    }
  end
  FileUtils.mkdir_p File.dirname(filename)
  File.open(filename, "w:UTF-8") { | file |
    file.print "//[stateconv] Generated by stateconv. Do not modify this line. [hash:#{hash}]\n\n"
    file.print source
    unless current_file.empty?
      file.print "\n#if false //disabled by stateconv\n"
      file.print current_file
      file.print "\n#endif //disabled by stateconv\n"
    end
  }
  
  if newly_created
    puts "#{filename} is created."
  else
    puts "#{filename} is modified."
  end
end

def save_skelton
  filename = "#{CS_ROOT}/#{BASENAME}/#{BASENAME}.cs"
  return if File.exist? filename
  FileUtils.mkdir_p File.dirname(filename)
  File.open(filename, "w:UTF-8") { | file |
    file.print <<END
using System;
using System.Collections.Generic;
using Gree.Ville;

namespace #{NAMESPACE}
{
    public partial class #{T}
    {
        public #{T}()
        {
            initState();
        }

        public void Update()
        {
            execState();
        }
    }
}
END
  }
  puts "#{filename} is created."
end


def clean_file(funcname)
  filename = "#{CS_ROOT}/#{BASENAME}/StateMachine/#{BASENAME}#{funcname}.cs"
  current_file = ""
  if File.exist?(filename)
    File.open(filename,"r:UTF-8"){ | file |
      while l = file.gets
        unless l =~ /\/\/\[stateconv\].*\[hash:(.*)\]/
          current_file << l
        end
      end
    }
  end
  FileUtils.mkdir_p File.dirname(filename)
  File.open(filename, "w:UTF-8") { | file |
    unless current_file.empty?
      file.print "\n#if false //disabled by stateconv\n"
      file.print current_file
      file.print "\n#endif //disabled by stateconv\n"
    end
  }
  puts "#{filename} is disabled. You should remove this file."
end

old_cs_files = Dir.glob("#{CS_ROOT}/#{BASENAME}/StateMachine/*.cs").map do | f |
  File.basename(f,".cs").sub(/#{BASENAME}/,"")
end

data = YamlState.new
data.add(file)

export_graph(data)

save_skelton
root = []
data.nodes.sort{|a,b| a.name <=> b.name }.each do | node |
  next unless node.rlink.empty?
  root << node
end

source = <<END
using System;
using System.Collections.Generic;
using Gree.Ville;

namespace #{NAMESPACE}
{
    public partial class #{T}
    {
        private StateMachine mStateMachine;

        private void initState()
        {
            mStateMachine = new StateMachine("#{T}");
END
root.each_with_index do | node, i |
p = ""
p = "//" if i != 0
source += <<END
            #{p}mStateMachine.Spawn(State#{node.name});
END
end

source += <<END
        }

        private void execState()
        {
            mStateMachine.Exec();
        }
    }
}
END

save("InitState",source)
old_cs_files.delete("InitState")

data.nodes.each do |n|
  func_name = "State#{n.name}"
	source = <<END
using System;
using System.Collections.Generic;
using Gree.Ville;

namespace #{NAMESPACE}
{
    public partial class #{T}
    {

        private void #{func_name}()
        {
            //TODO: Something to execute every frame while this state.
END

	case n.link.length
	when 0
    source += <<END
            if (false)
            {
                mStateMachine.Exit();
            }
END
	when 1
	  link = n.link[0]
		condition = link.condition
		if condition.nil?
			indent = ""
		else
			indent = "    "
			source += <<END
            if (#{to_condition_text(condition)})
            {
END
		end

		source += <<END
            #{indent}mStateMachine.SwitchTo(State#{link.to.name});#{to_comment_text(link.comment)}
END

		if indent != ""
			source += <<END
            }
END
		end
	else
		count = 0
		n.link.sort{|a,b|
		  if a.condition.nil? == b.condition.nil?
		    a.to.name <=> b.to.name
		  elsif a.condition.nil?
		    1
		  else
		    -1
		  end
		}.each do | link |
      if link.spawn
        source += <<END
            mStateMachine.Spawn(State#{link.to.name});#{to_comment_text(link.comment)}
END
				source.puts
      end
    end

		n.link.sort{|a,b|
		  if a.condition.nil? == b.condition.nil?
		    a.to.name <=> b.to.name
		  elsif a.condition.nil?
		    1
		  else
		    -1
		  end
		}.each do | link |
	    next if link.spawn
		  condition = link.condition
			if count == 0
			  source += <<END
            if (#{to_condition_text(condition)})
            {
END
			elsif link.condition.nil? && count == n.link.size-1
				source += <<END
            }
            else
            {
END
      else
				source += <<END
            }
            else if (#{to_condition_text(condition)})
            {
END
			end
			count += 1

      source += <<END
                mStateMachine.SwitchTo(State#{link.to.name});#{to_comment_text(link.comment)}
END
		end
		source += <<END
            }
END
	end

	source += <<END
        }
    }
}
END
  save(func_name,source)
  old_cs_files.delete(func_name)
end

old_cs_files.each do | file |
  clean_file(file)
end
